如何判断拖拽节点A是否应该嵌套进容器B一般来说，有多种方案可以选择：A：鼠标进入容器YB：节点X矩形和容器Y矩形相交C：节点X矩形完全包裹进容器YFigma的容器嵌套采用的是A方案；Framer的容器嵌套采用了A和C，当Y容器属于根级容器时，运用A方案，当Y容器有嵌套父容器时，采用C方案以下是示例【左侧为Figma，右侧为Framer】：可以看到第一层嵌套时【图左红色节点和图右紫色节点】，Figma和Framer都采用了A方案判断容器是否嵌套当第二层嵌套时，Figma和Framer都限制了容器大小，当移动容器尺寸大于嵌套容器时，都不会进行嵌套棕色节点和图右绿色节点】；而当尺寸限制达标时，Figma仍然使用A方案判断【图左粉红色节点】，Framer则采用C方案判断【图右白色节点】参考以上两大设计软件，基本上定制出自己的嵌套判断策略目标是否嵌套容器：B.containerTypeisContainer嵌套条件是否触发：A.mousePositionisInB嵌套是否限制：B.isTopContainer||A.size<B.size架构调整和解决方案画布二期架构：存储侧：当前的二期画布搭建，采用节点平铺的方式，只进行了一个页面容器的嵌套，该页面容器嵌套也只是单独特殊处理，节点存储方式仍然为一维数组存储。是否嵌套在页面中使用了isEffect标识渲染侧：遍历节点数组，统一在一个StackWidget上渲染辅助线：节点拖拽过程中，所有节点参与辅助线计算【性能优化无关节点除外】节点嵌套：根据嵌套逻辑判断A方案，更新节点的isEffect标识。节点圈选：所有节点参与圈选计算。圈选计算逻辑：圈选框和目标元素矩形相交即选中节点选中：按节点层级优先级，确定包含鼠标坐标位置的第一个节点，即选中节点删除:选中节点删除节点hover：除Page节点，其他节点按层级优先级计算鼠标是否在节点矩形范围内其他等等；二期嵌套未解决的问题：节点在嵌套容器内不是overflowhidden的。该问题取决于渲染侧逻辑。三期架构方案：存储侧：为了更好地处理嵌套元素的集体拖拽、更方便地处理渲染侧逻辑来进行嵌套的UI表达等原因，需要维护嵌套元素的父子关系，所以通过扩展节点属性增加parent和children字段，基于一维数组建立树结构；同时为了降低代码复杂度，更高效的处理渲染、辅助线计算等，parent和children字段存储节点的唯一id，同时维护节点id和节点之间的Map关系，这样通过一个节点A.parent，无须遍历数组即可访问到对应的A节点。渲染侧：遍历节点数组，只渲染非嵌套元素，即node.parent==null;recursive；对于X.children同样应用上述第2步由于被嵌套元素都是在嵌套元素的Stack上渲染，所以天然解决二期画布的遗留问题，可以将嵌套元素限制在ClipRect中进行裁剪，营造出元素被嵌套的视觉效果上图示例中，A在一个Stack上渲染，B、C、D在一个Stack上渲染，E、F在一个Stack上渲染，G在一个Stack上渲染节点嵌套：节点拖拽过程中，根据上文的嵌套逻辑条件判断触发时，涉及到三个节点的信息更新，以上图节点B嵌套进入节点C为例子，按以下步骤更新树结构信息：更新B节点的父节点：B.parent=C;更新C节点的子节点：C.children.add(B);更新A节点的子节点：A.children.remove(B);为了更高效的完成上述过程的信息更新，需要借助储存结构中维护的nodeId和node实例的map映射。完成后新的树结构如下辅助线：被嵌套元素A拖拽过程中，只有A.parent.children的元素参与辅助线计算【性能优化无关节点除外】非被嵌套元素拖拽过程中，只有Node.parent==null的元素参与辅助线计算【性能优化无关节点除外】元素圈选：所有节点参加圈选计算圈选计算逻辑：1、根级元素【非容器类型】：圈选区域和节点矩形相交即选中；2、根级元素【容器类型】：如果不包含嵌套元素，则相交即选中，否则圈选区域完全包裹节点矩形才选中；3、其他节点：圈选区域和节点矩形相交即选中4、限制：一个节点只有其任一父级没选中才能被选中。节点选中：层层递进，嵌套元素需要先选中其父节点，然后通过双击选中；节点删除:选中节点以及其他的所有子孙children一起删除，同时需要维护受影响的parent节点hover：根容器节点不参与计算，其他节点按树广度优先计算生效节点其他等等；